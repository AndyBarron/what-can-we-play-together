const axios = require('axios');
const config = require('./config');

const API_KEY = config.STEAM_API_KEY;
const MAX_PLAYER_SUMMARIES = 100;

// TODO: Caching?
const api = (interface, method, params, version = 1) => {
  let urlParams = '';
  if (params) {
    for (const key in params) {
      const value = params[key];
      let urlValue;
      if (value === true) {
        urlValue = 1;
      } else if (value === false) {
        urlValue = 0;
      } else {
        urlValue = value;
      }
      urlParams += `&${key}=${urlValue}`;
    }
  }
  const versionString = 'v' + version.toString().padStart('4', '0');
  const url =
    `https://api.steampowered.com/${interface}/${method}/${versionString}/?key=${API_KEY}${urlParams}`;
  console.log(url);
  return axios({url: url}).then(out => out.data);
};

const getPlayerSummaries = async (steamids) => {
  if (steamids.length <= MAX_PLAYER_SUMMARIES) {
    steamids = steamids.join(',');
    const result = await api('ISteamUser', 'GetPlayerSummaries', {steamids});
    return result.response.players.player;
  } else {
    const idChunks = [];
    for (let i = 0; i < steamids.length; i += MAX_PLAYER_SUMMARIES) {
      const chunk = steamids.slice(i, i + MAX_PLAYER_SUMMARIES);
      console.log('chunk', chunk);
      idChunks.push(chunks);
    }
    const promises = idChunks.map(getPlayerSummaries);
    const summaryChunks = await Promise.all(promises);
    return summaryChunks.reduce((a, b) => a.concat(b), []);
  }
};

const getFriendIds = async (steamid) => {
  const response = await api('ISteamUser', 'GetFriendList', {steamid});
  const friends = response.friendslist.friends;
  return friends.map(info => info.steamid);
};

const userFromSummary = (info) => ({
  id: info.steamid,
  name: info.personaname,
  realName: info.realname,
  avatarUrl: info.avatarfull,
  profileUrl: info.profileurl,
});

const getUser = async (steamid) => {
  const info = (await getPlayerSummaries([steamid]))[0];
  // TODO: Error message if info.communityvisibilitystate == 1 (profile unavailable)
  //       or info.profilestate != 1 (profile not set up)
  const user = userFromSummary(info);
  const friendIds = await getFriendIds(steamid);
  const friendSummaries = await getPlayerSummaries(friendIds);
  const friends = friendSummaries.map(userFromSummary);
  friends.sort((a, b) => parseInt(a.id) - parseInt(b.id));
  user.friends = friends;
  return user;
};

const appImageUrl = (id, hash) => {
  if (!id || !hash) {
    return null;
  }
  return `//media.steampowered.com/steamcommunity/public/images/apps/${id}/${hash}.jpg`;
}

const gameFromSummary = (info) => ({
  id: info.appid,
  name: info.name,
  iconUrl: appImageUrl(info.appid, info.img_icon_url),
  logoUrl: appImageUrl(info.appid, info.img_logo_url),
});

const getOwnedGameIds = async (steamid, gameCache) => {
  const options = {
    steamid,
    include_appinfo: 1,
    include_played_free_games: 1,
  };
  const result = await api('IPlayerService', 'GetOwnedGames', options);
  let ids;
  if (gameCache) {
    const games = result.response.games.map(gameFromSummary);
    for (const game of games) {
      gameCache.set(game.id, game);
    }
    ids = games.map(game => game.id);
  } else {
    ids = result.response.games.map(info => info.appid);
  }
  return ids.sort((a, b) => a - b);
};

const getIdFromVanityUrlName = async (name) => {
  const result = await api('ISteamUser', 'ResolveVanityURL', {vanityurl: name});
  const id = result.response.steamid;
  return id || name;
};

module.exports = {
  api,
  getUser,
  getIdFromVanityUrlName,
  getOwnedGameIds,
};
