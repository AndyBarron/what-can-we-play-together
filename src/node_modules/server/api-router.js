const express = require('express');
const steam = require('./steam');

const router = express.Router();

const sendJson = (req, res, data) => {
  if (req.xhr) {
    res.json(data);
  } else {
    res.type('text/json').send(JSON.stringify(data, null, 2));
  }
}

const routes = {
  '/user/:idOrVanityName': async (req, res) => {
    const steamid = await steam.getIdFromVanityUrlName(req.params.idOrVanityName);
    const user = await steam.getUser(steamid);
    sendJson(req, res, user);
  },
  '/games/:userIds': async (req, res) => {
    const userIds = req.params.userIds.split(',');
    const gameCache = new Map();
    const userToGameIdSet = new Map();
    const gamePromises = [];
    for (const userId of userIds) {
      const promise = new Promise(async (resolve, reject) => {
        const ownedGameIds = await steam.getOwnedGameIds(userId, gameCache);
        userToGameIdSet.set(userId, new Set(ownedGameIds));
        resolve();
      });
      gamePromises.push(promise);
    }
    await Promise.all(gamePromises);
    for (const [userId, gameIds] of userToGameIdSet) {
      console.log(userId, 'owns', gameIds.size, 'games');
    }
    let gameIdList = null;
    for (const gameIdSet of userToGameIdSet.values()) {
      if (gameIdList === null) {
        gameIdList = Array.from(gameIdSet);
      } else {
        gameIdList = gameIdList.filter(id => gameIdSet.has(id));
      }
    }
    console.log(gameIdList.length, 'games in common');
    const gameList = gameIdList.map(id => gameCache.get(id));
    sendJson(req, res, gameList);
  },
};

for (const [route, handler] of Object.entries(routes)) {
  router.get(route, async (req, res) => {
    try {
      await handler(req, res);
    } catch (e) {
      console.error('Internal error:');
      console.error(e);
      res.status(500);
      sendJson(req, res, {'message': 'An error occurred.'});
    }
  });
}

module.exports = router;
